/**
 * SOPDataMapper - ProcessAudit AI
 * 
 * Maps SOPRevision component data format to SOPDocument format for PDF generation
 * Handles the conversion between the revision workflow data and PDF-compatible structure
 */

/**
 * SOP Data Mapper
 * Converts SOPRevision format to SOPDocument format for PDF generation
 */
class SOPDataMapper {
  
  /**
   * Convert SOPRevision data to SOPDocument format
   * @param {Object|string} sopRevisionData - Data from SOPRevision component
   * @param {Object} metadata - Additional metadata for the document
   * @param {string} revisionType - Type of revision ('original', 'revised', 'optimized')
   * @returns {Object} SOPDocument format for PDF generation
   */
  static convertToSOPDocument(sopRevisionData, metadata = {}, revisionType = 'revised') {
    // Handle string format (plain text SOPs)
    if (typeof sopRevisionData === 'string') {
      return SOPDataMapper._convertStringSOPToDocument(sopRevisionData, metadata, revisionType)
    }

    // Handle structured object format
    if (typeof sopRevisionData === 'object' && sopRevisionData !== null) {
      return SOPDataMapper._convertStructuredSOPToDocument(sopRevisionData, metadata, revisionType)
    }

    // Fallback for invalid data
    throw new Error('Invalid SOP data format. Expected string or structured object.')
  }

  /**
   * Convert string-based SOP to SOPDocument format
   * @private
   */
  static _convertStringSOPToDocument(sopText, metadata, revisionType) {
    return {
      metadata: {
        title: metadata.title || 'Standard Operating Procedure',
        sopVersion: metadata.version || '1.0',
        effectiveDate: metadata.effectiveDate || new Date(),
        reviewDate: metadata.reviewDate || new Date(Date.now() + 365 * 24 * 60 * 60 * 1000), // 1 year from now
        approvalStatus: revisionType === 'original' ? 'draft' : 'approved',
        documentId: metadata.documentId || 'SOP-GEN-001',
        department: metadata.department || 'Operations',
        processOwner: metadata.processOwner || 'Process Owner',
        classification: 'internal',
        author: 'ProcessAudit AI',
        approver: revisionType !== 'original' ? {
          name: metadata.approver || 'Process Manager',
          title: 'Process Manager',
          date: new Date()
        } : undefined
      },
      purpose: SOPDataMapper._extractSection(sopText, 'PURPOSE') || 'This SOP defines the standard operating procedure for the business process.',
      scope: SOPDataMapper._extractSection(sopText, 'SCOPE') || 'This procedure applies to all personnel involved in the process.',
      responsibilities: SOPDataMapper._parseResponsibilities(sopText),
      procedures: SOPDataMapper._parseProcedures(sopText),
      relatedDocuments: [
        {
          title: 'ProcessAudit AI Analysis Report',
          reference: 'Generated by ProcessAudit AI',
          type: 'external'
        }
      ],
      revisionHistory: [
        {
          version: '1.0',
          date: new Date(),
          author: 'ProcessAudit AI',
          changes: `${revisionType.charAt(0).toUpperCase() + revisionType.slice(1)} version generated from process analysis`
        }
      ]
    }
  }

  /**
   * Convert structured SOP object to SOPDocument format
   * @private
   */
  static _convertStructuredSOPToDocument(sopObject, metadata, revisionType) {
    const header = sopObject.header || {}
    
    return {
      metadata: {
        title: header.title || metadata.title || 'Standard Operating Procedure',
        sopVersion: header.version || metadata.version || '1.0',
        effectiveDate: header.effectiveDate ? new Date(header.effectiveDate) : new Date(),
        reviewDate: header.reviewDate ? new Date(header.reviewDate) : new Date(Date.now() + 365 * 24 * 60 * 60 * 1000),
        approvalStatus: revisionType === 'original' ? 'draft' : 'approved',
        documentId: header.sopNumber || metadata.documentId || 'SOP-REV-001',
        department: metadata.department || 'Operations',
        processOwner: header.preparedBy || metadata.processOwner || 'Process Owner',
        classification: 'internal',
        author: header.preparedBy || 'ProcessAudit AI',
        approver: revisionType !== 'original' ? {
          name: metadata.approver || 'Process Manager',
          title: 'Process Manager',
          date: new Date()
        } : undefined
      },
      purpose: sopObject.purpose || 'This SOP defines the standard operating procedure for the business process.',
      scope: sopObject.scope || 'This procedure applies to all personnel involved in the process.',
      responsibilities: SOPDataMapper._convertResponsibilities(sopObject.responsibilities),
      procedures: SOPDataMapper._convertProcedures(sopObject.procedure),
      relatedDocuments: [
        {
          title: 'ProcessAudit AI Analysis Report',
          reference: 'Generated by ProcessAudit AI',
          type: 'external'
        }
      ],
      revisionHistory: [
        {
          version: header.version || '1.0',
          date: header.effectiveDate ? new Date(header.effectiveDate) : new Date(),
          author: header.preparedBy || 'ProcessAudit AI',
          changes: `${revisionType.charAt(0).toUpperCase() + revisionType.slice(1)} version generated from process optimization`
        }
      ]
    }
  }

  /**
   * Extract section text from plain text SOP
   * @private
   */
  static _extractSection(text, sectionName) {
    const regex = new RegExp(`${sectionName}\\s*\\n([\\s\\S]*?)(?=\\n[A-Z][A-Z\\s]*\\n|$)`, 'i')
    const match = text.match(regex)
    return match ? match[1].trim() : null
  }

  /**
   * Parse responsibilities from text
   * @private
   */
  static _parseResponsibilities(text) {
    const responsibilities = []
    const responsibilitiesSection = SOPDataMapper._extractSection(text, 'RESPONSIBILITIES')
    
    if (responsibilitiesSection) {
      const lines = responsibilitiesSection.split('\n')
      lines.forEach(line => {
        const match = line.match(/^(.+?):\s*(.+)$/)
        if (match) {
          responsibilities.push({
            role: match[1].trim(),
            description: match[2].trim()
          })
        }
      })
    }

    // Default responsibilities if none found
    if (responsibilities.length === 0) {
      responsibilities.push({
        role: 'Process Owner',
        description: 'Responsible for overall process governance and execution'
      })
    }

    return responsibilities
  }

  /**
   * Parse procedures from text
   * @private
   */
  static _parseProcedures(text) {
    const procedures = []
    const procedureSection = SOPDataMapper._extractSection(text, 'PROCEDURE')
    
    if (procedureSection) {
      const steps = []
      const stepMatches = procedureSection.match(/^\d+\..*/gm)
      
      if (stepMatches) {
        stepMatches.forEach((stepText, index) => {
          const stepMatch = stepText.match(/^(\d+)\.\s*(.+)/)
          if (stepMatch) {
            steps.push({
              stepNumber: parseInt(stepMatch[1]),
              title: stepMatch[2].trim(),
              description: stepMatch[2].trim(),
              instructions: [stepMatch[2].trim()],
              expectedOutcome: `Successful completion of ${stepMatch[2].trim().toLowerCase()}`,
              timeEstimate: 15 // Default time estimate
            })
          }
        })
      }

      if (steps.length > 0) {
        procedures.push({
          name: 'Standard Operating Procedures',
          steps
        })
      }
    }

    // Default procedure if none found
    if (procedures.length === 0) {
      procedures.push({
        name: 'Standard Operating Procedures',
        steps: [
          {
            stepNumber: 1,
            title: 'Follow Established Process',
            description: 'Execute the standard operating procedure as defined',
            instructions: ['Follow established process guidelines'],
            expectedOutcome: 'Successful process execution',
            timeEstimate: 30
          }
        ]
      })
    }

    return procedures
  }

  /**
   * Convert structured responsibilities to SOPDocument format
   * @private
   */
  static _convertResponsibilities(responsibilities) {
    if (!responsibilities) return []
    
    if (typeof responsibilities === 'object' && !Array.isArray(responsibilities)) {
      // Handle object format: { role: description }
      return Object.entries(responsibilities).map(([role, description]) => ({
        role: role.trim(),
        description: description.trim()
      }))
    }
    
    if (Array.isArray(responsibilities)) {
      // Handle array format - already in correct format
      return responsibilities.map(resp => ({
        role: resp.role || 'Unspecified Role',
        description: resp.description || 'Responsibility not specified'
      }))
    }

    return []
  }

  /**
   * Convert structured procedure to SOPDocument format
   * @private
   */
  static _convertProcedures(procedure) {
    if (!procedure || !Array.isArray(procedure)) return []
    
    const steps = procedure.map((step, index) => ({
      stepNumber: step.step || index + 1,
      title: step.action || `Step ${index + 1}`,
      description: step.action || `Process step ${index + 1}`,
      instructions: step.action ? [step.action] : [],
      prerequisites: step.responsibility ? [step.responsibility] : [],
      expectedOutcome: step.qualityCriteria || `Successful completion of ${step.action || 'step'}`,
      timeEstimate: SOPDataMapper._parseTimeEstimate(step.timing),
      resources: step.materialsEquipment ? [step.materialsEquipment] : [],
      risks: [],
      qualityChecks: step.qualityCriteria ? [step.qualityCriteria] : []
    }))

    return [
      {
        name: 'Process Procedures',
        steps
      }
    ]
  }

  /**
   * Parse time estimate from timing text
   * @private
   */
  static _parseTimeEstimate(timing) {
    if (!timing) return 15 // Default 15 minutes
    
    const match = timing.match(/(\d+)\s*(min|minute|hour|hr)/i)
    if (match) {
      const value = parseInt(match[1])
      const unit = match[2].toLowerCase()
      
      if (unit.includes('hour') || unit.includes('hr')) {
        return value * 60 // Convert hours to minutes
      }
      return value
    }
    
    return 15 // Default fallback
  }

  /**
   * Generate download filename for SOP PDF
   * @param {Object} sopData - SOP document data
   * @param {string} revisionType - Type of revision
   * @returns {string} Generated filename
   */
  static generateFilename(sopData, revisionType = 'sop') {
    const title = sopData.metadata?.title || 'Standard Operating Procedure'
    const version = sopData.metadata?.sopVersion || '1.0'
    const date = new Date().toISOString().split('T')[0]
    
    // Sanitize title for filename
    const sanitizedTitle = title
      .replace(/[^a-zA-Z0-9\s]/g, '')
      .replace(/\s+/g, '-')
      .substring(0, 50) // Limit length
    
    return `${sanitizedTitle}-${revisionType}-v${version}-${date}.pdf`
  }

  /**
   * Get appropriate metadata based on revision type
   * @param {string} revisionType - Type of revision
   * @param {Object} additionalMetadata - Additional metadata to include
   * @returns {Object} Metadata configuration for PDF
   */
  static getRevisionMetadata(revisionType, additionalMetadata = {}) {
    const baseMetadata = {
      author: 'ProcessAudit AI',
      subject: 'Standard Operating Procedure',
      keywords: ['SOP', 'procedure', 'operations', revisionType],
      createdDate: new Date(),
      ...additionalMetadata
    }

    switch (revisionType) {
      case 'original':
        return {
          ...baseMetadata,
          title: `Original SOP - ${additionalMetadata.title || 'Business Process'}`,
          classification: 'draft'
        }
        
      case 'revised':
        return {
          ...baseMetadata,
          title: `Revised SOP - ${additionalMetadata.title || 'Business Process'}`,
          classification: 'internal'
        }
        
      case 'optimized':
        return {
          ...baseMetadata,
          title: `Optimized SOP - ${additionalMetadata.title || 'Business Process'}`,
          classification: 'internal'
        }
        
      default:
        return {
          ...baseMetadata,
          title: `SOP - ${additionalMetadata.title || 'Business Process'}`,
          classification: 'internal'
        }
    }
  }

  /**
   * Validate SOP data before conversion
   * @param {Object|string} sopData - SOP data to validate
   * @returns {Object} Validation result
   */
  static validateSOPData(sopData) {
    const errors = []
    const warnings = []

    if (!sopData) {
      errors.push('SOP data is required')
      return { valid: false, errors, warnings }
    }

    if (typeof sopData === 'string') {
      if (sopData.trim().length < 10) {
        errors.push('SOP text content is too short')
      }
      
      if (!sopData.includes('PURPOSE') && !sopData.includes('PROCEDURE')) {
        warnings.push('SOP does not contain standard sections (PURPOSE, PROCEDURE)')
      }
    } else if (typeof sopData === 'object') {
      if (!sopData.purpose && !sopData.procedure) {
        warnings.push('SOP object missing key sections (purpose, procedure)')
      }
      
      if (sopData.procedure && Array.isArray(sopData.procedure) && sopData.procedure.length === 0) {
        warnings.push('SOP procedure array is empty')
      }
    } else {
      errors.push('SOP data must be string or object')
    }

    return {
      valid: errors.length === 0,
      errors,
      warnings
    }
  }

  /**
   * Generate comparison data for revision PDFs
   * @param {Object|string} originalSOP - Original SOP data
   * @param {Object|string} revisedSOP - Revised SOP data
   * @returns {Object} Comparison data for PDF
   */
  static generateComparisonData(originalSOP, revisedSOP) {
    const originalDoc = SOPDataMapper.convertToSOPDocument(originalSOP, {}, 'original')
    const revisedDoc = SOPDataMapper.convertToSOPDocument(revisedSOP, {}, 'revised')

    return {
      original: originalDoc,
      revised: revisedDoc,
      changes: {
        purposeChanged: originalDoc.purpose !== revisedDoc.purpose,
        scopeChanged: originalDoc.scope !== revisedDoc.scope,
        responsibilitiesChanged: JSON.stringify(originalDoc.responsibilities) !== JSON.stringify(revisedDoc.responsibilities),
        proceduresChanged: JSON.stringify(originalDoc.procedures) !== JSON.stringify(revisedDoc.procedures),
        changeCount: SOPDataMapper._countChanges(originalDoc, revisedDoc)
      },
      metadata: {
        comparisonDate: new Date(),
        revisionReason: 'Process optimization through AI analysis',
        changesSummary: 'Optimized for efficiency and automation opportunities'
      }
    }
  }

  /**
   * Count changes between two SOP documents
   * @private
   */
  static _countChanges(original, revised) {
    let changes = 0
    
    if (original.purpose !== revised.purpose) changes++
    if (original.scope !== revised.scope) changes++
    if (JSON.stringify(original.responsibilities) !== JSON.stringify(revised.responsibilities)) changes++
    if (JSON.stringify(original.procedures) !== JSON.stringify(revised.procedures)) changes++
    
    return changes
  }
}

module.exports = SOPDataMapper